<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>zerocount: bistritz.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">zerocount
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Zero counting algorithms for polynomials</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bistritz.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>source code for Bistritz_rule and auxiliary functions  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;flint/flint.h&quot;</code><br />
<code>#include &quot;flint/fmpz.h&quot;</code><br />
<code>#include &quot;flint/fmpq.h&quot;</code><br />
<code>#include &quot;flint/fmpq_poly.h&quot;</code><br />
<code>#include &quot;<a class="el" href="debug_8h_source.html">debug.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a69fb049cdc47f06f6a700dedb019c2c9"><td class="memItemLeft" align="right" valign="top">slong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#a69fb049cdc47f06f6a700dedb019c2c9">get_lambda</a> (const fmpq_poly_t poly)</td></tr>
<tr class="memdesc:a69fb049cdc47f06f6a700dedb019c2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of lowest non-zero term;.  <a href="#a69fb049cdc47f06f6a700dedb019c2c9">More...</a><br /></td></tr>
<tr class="separator:a69fb049cdc47f06f6a700dedb019c2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548f5703cb4e36372f8d47c381007994"><td class="memItemLeft" align="right" valign="top">const fmpz *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#a548f5703cb4e36372f8d47c381007994">get_coeff_numref</a> (const fmpq_poly_t poly, const fmpz_t const_null, const slong n)</td></tr>
<tr class="memdesc:a548f5703cb4e36372f8d47c381007994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to numerator of n-th coefficient or 0 if index n is out of range.  <a href="#a548f5703cb4e36372f8d47c381007994">More...</a><br /></td></tr>
<tr class="separator:a548f5703cb4e36372f8d47c381007994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f260f914469ff1b8cb24aac32fd047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#ad4f260f914469ff1b8cb24aac32fd047">get_coeff</a> (fmpq_t coeff, const fmpq_poly_t poly, const slong n)</td></tr>
<tr class="memdesc:ad4f260f914469ff1b8cb24aac32fd047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns n-th coefficient of poly or 0 if index n is out of range.  <a href="#ad4f260f914469ff1b8cb24aac32fd047">More...</a><br /></td></tr>
<tr class="separator:ad4f260f914469ff1b8cb24aac32fd047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca22e6df635f27603116e1689fbcd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#a21ca22e6df635f27603116e1689fbcd4">get_delta</a> (fmpq_t delta, const fmpq_poly_t T_prev, const fmpq_poly_t T_curr)</td></tr>
<tr class="memdesc:a21ca22e6df635f27603116e1689fbcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates delta coefficient for the three-term recursion.  <a href="#a21ca22e6df635f27603116e1689fbcd4">More...</a><br /></td></tr>
<tr class="separator:a21ca22e6df635f27603116e1689fbcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec739005e4452bd18e2611f3c42080bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#aec739005e4452bd18e2611f3c42080bd">div_x_minus_1_asym</a> (fmpq_poly_t res, const fmpq_poly_t poly)</td></tr>
<tr class="memdesc:aec739005e4452bd18e2611f3c42080bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides antisymmetric P(x) (P*=-P) by (x-1) in Q[x], returns quotient.  <a href="#aec739005e4452bd18e2611f3c42080bd">More...</a><br /></td></tr>
<tr class="separator:aec739005e4452bd18e2611f3c42080bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5d65b06fef70ec6526bf54ab2518f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#a6a5d65b06fef70ec6526bf54ab2518f4">eval_at_1_sym</a> (fmpq_t val, const fmpq_poly_t poly)</td></tr>
<tr class="memdesc:a6a5d65b06fef70ec6526bf54ab2518f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates formaly-symmetric polynomial at x=1.  <a href="#a6a5d65b06fef70ec6526bf54ab2518f4">More...</a><br /></td></tr>
<tr class="separator:a6a5d65b06fef70ec6526bf54ab2518f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c3cc765eb0e2b71d7f3577ec66c046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#aa1c3cc765eb0e2b71d7f3577ec66c046">clear_x_minus_1</a> (slong *count, fmpq_poly_t poly)</td></tr>
<tr class="memdesc:aa1c3cc765eb0e2b71d7f3577ec66c046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeatedly divides P(x) by (x-1) until P(-1)&lt;&gt;0, returns quotient.  <a href="#aa1c3cc765eb0e2b71d7f3577ec66c046">More...</a><br /></td></tr>
<tr class="separator:aa1c3cc765eb0e2b71d7f3577ec66c046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c6d0660a092928a2bc314e57270136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#a52c6d0660a092928a2bc314e57270136">rule_init</a> (fmpq_poly_t T1, fmpq_poly_t T2, fmpq_t sigma1, fmpq_t sigma2, const fmpq_poly_t D)</td></tr>
<tr class="memdesc:a52c6d0660a092928a2bc314e57270136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes polynomials T1, T2 and their signs at x=1.  <a href="#a52c6d0660a092928a2bc314e57270136">More...</a><br /></td></tr>
<tr class="separator:a52c6d0660a092928a2bc314e57270136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17b20e64b376242912269d3270ac337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#ad17b20e64b376242912269d3270ac337">print_T_data</a> (slong n, fmpq_poly_t T, fmpq_t sigma)</td></tr>
<tr class="memdesc:ad17b20e64b376242912269d3270ac337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debuging function; prints the recursion data to the stdout.  <a href="#ad17b20e64b376242912269d3270ac337">More...</a><br /></td></tr>
<tr class="separator:ad17b20e64b376242912269d3270ac337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83451a1357feb4b01a1f41e2ca85cf54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#a83451a1357feb4b01a1f41e2ca85cf54">do_singular</a> (fmpq_poly_t T1, fmpq_poly_t T2, fmpq_poly_t T3, fmpq_t sigma1, fmpq_t sigma2, fmpq_t sigma3)</td></tr>
<tr class="memdesc:a83451a1357feb4b01a1f41e2ca85cf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-initializes polynomials T2, T3 and their signs at x=1 in singular cases.  <a href="#a83451a1357feb4b01a1f41e2ca85cf54">More...</a><br /></td></tr>
<tr class="separator:a83451a1357feb4b01a1f41e2ca85cf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444b3f4facb54e29a3f12ef74b88bb40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#a444b3f4facb54e29a3f12ef74b88bb40">do_recurence</a> (fmpq_poly_t T3, fmpq_t sigma3, fmpq_t delta, const fmpz_t fmpz_const_null, const fmpq_poly_t T1, const fmpq_poly_t T2, const fmpq_t sigma1, const fmpq_t sigma2, const slong flength)</td></tr>
<tr class="memdesc:a444b3f4facb54e29a3f12ef74b88bb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates next polynomial T3 in regular recursion.  <a href="#a444b3f4facb54e29a3f12ef74b88bb40">More...</a><br /></td></tr>
<tr class="separator:a444b3f4facb54e29a3f12ef74b88bb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac08110815e4b854dc83dd15f914fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bistritz_8c.html#abac08110815e4b854dc83dd15f914fd6">Bistritz_rule</a> (slong *in_uc, slong *on_uc, const fmpq_poly_t poly)</td></tr>
<tr class="memdesc:abac08110815e4b854dc83dd15f914fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero counting procedure.  <a href="#abac08110815e4b854dc83dd15f914fd6">More...</a><br /></td></tr>
<tr class="separator:abac08110815e4b854dc83dd15f914fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>source code for Bistritz_rule and auxiliary functions </p>
<dl class="section author"><dt>Author</dt><dd>Jonas Jankauskas </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 22, 2019 </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>FLINT version 2.5.2</dd></dl>
<p>Contains the source code of the Bistritz algorithm, together with routines that perform calculations symmetric polynomials (saving about half of computational time) and 3-term Bistritz recurrence formula. Reasonable attempt to optimize the code for the speed was made without compromising the code readability. The program is implemented via FLINT. FLINT conventions are followed where possible: each function returns its result via the 1st argument. It is assumed that function arguments are initialized by user by appropriate FLINT initialization routines before the call. Unless the variable is declared const, users must assume that the function will modify the contents of that variable. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="abac08110815e4b854dc83dd15f914fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac08110815e4b854dc83dd15f914fd6">&#9670;&nbsp;</a></span>Bistritz_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bistritz_rule </td>
          <td>(</td>
          <td class="paramtype">slong *&#160;</td>
          <td class="paramname"><em>in_uc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong *&#160;</td>
          <td class="paramname"><em>on_uc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero counting procedure. </p>
<p>If poly &lt;&gt; 0, returns no. of complex zeros of poly inside |z| &lt; 1 and on |z| = 1 through *in_uc and *on_uc. If poly == 0, stores the pair of numbers -1, 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>- FLINT fmpq_poly_t type rational polynomial (must be initialized before the call) </td></tr>
    <tr><td class="paramname">in_uc</td><td>- pointer to FLINT slong, no. of complex zeros inside unit circle |z|&lt;1 </td></tr>
    <tr><td class="paramname">on_uc</td><td>- pointer to FLINT slong, no. of complex zeros on unit circle |z|=1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>results are returned through in_uc, on_uc variables </dd></dl>

</div>
</div>
<a id="aa1c3cc765eb0e2b71d7f3577ec66c046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c3cc765eb0e2b71d7f3577ec66c046">&#9670;&nbsp;</a></span>clear_x_minus_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_x_minus_1 </td>
          <td>(</td>
          <td class="paramtype">slong *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_poly_t&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeatedly divides P(x) by (x-1) until P(-1)&lt;&gt;0, returns quotient. </p>
<p>Quotient polynomial is obtained by a Horner-like evaluation at x=1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>- multiplicity of root x=1 in P(x). If P(x)=0, 0 is returned. </td></tr>
    <tr><td class="paramname">poly</td><td>- FLINT fmpq_poly_t type rational polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result is returned in count </dd></dl>

</div>
</div>
<a id="aec739005e4452bd18e2611f3c42080bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec739005e4452bd18e2611f3c42080bd">&#9670;&nbsp;</a></span>div_x_minus_1_asym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void div_x_minus_1_asym </td>
          <td>(</td>
          <td class="paramtype">fmpq_poly_t&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides antisymmetric P(x) (P*=-P) by (x-1) in Q[x], returns quotient. </p>
<p>Horner evaluation at 1 and exploitation of negative-symmetry </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>- quotient polynomial, FLINT fmpq_poly_t type </td></tr>
    <tr><td class="paramname">poly</td><td>- rational polynomial that is to be divided, FLINT fmpq_poly_t type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result is returned in res </dd></dl>

</div>
</div>
<a id="a444b3f4facb54e29a3f12ef74b88bb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444b3f4facb54e29a3f12ef74b88bb40">&#9670;&nbsp;</a></span>do_recurence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void do_recurence </td>
          <td>(</td>
          <td class="paramtype">fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>sigma3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpz_t&#160;</td>
          <td class="paramname"><em>fmpz_const_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_t&#160;</td>
          <td class="paramname"><em>sigma1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_t&#160;</td>
          <td class="paramname"><em>sigma2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const slong&#160;</td>
          <td class="paramname"><em>flength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates next polynomial T3 in regular recursion. </p>
<p>T3 = delta*(z^(2*lambda+1)+1)*T_2*z^(-lambda) - T1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T3</td><td>- new polynomial of the recurrence, FLINT fmpq_poly_t type </td></tr>
    <tr><td class="paramname">sigma3</td><td>- sign of next polynomial T3 at x=1, fmpq_t type rational number </td></tr>
    <tr><td class="paramname">delta</td><td>- placeholder for the recursion coefficient </td></tr>
    <tr><td class="paramname">fmpz_const_null</td><td>- fmpz_t placeholder for '0' </td></tr>
    <tr><td class="paramname">T1</td><td>- pre-previous polynomial of the recurrence, FLINT fmpq_poly_t type </td></tr>
    <tr><td class="paramname">T2</td><td>- previous polynomial of the recurrence, FLINT fmpq_poly_t type </td></tr>
    <tr><td class="paramname">sigma1</td><td>- sign of T1 at x=1, fmpq_t type rational number </td></tr>
    <tr><td class="paramname">sigma2</td><td>- sign of T2 at x=1, fmpq_t type rational number </td></tr>
    <tr><td class="paramname">flength</td><td>- FLINT slong (formal) symmetrical length of the next polynomial, used in #-operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>results are stored in T3, sigma3, delta </dd></dl>

</div>
</div>
<a id="a83451a1357feb4b01a1f41e2ca85cf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83451a1357feb4b01a1f41e2ca85cf54">&#9670;&nbsp;</a></span>do_singular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void do_singular </td>
          <td>(</td>
          <td class="paramtype">fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>sigma1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>sigma2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>sigma3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-initializes polynomials T2, T3 and their signs at x=1 in singular cases. </p>
<p>D = T1', T2 = (D+D*), T3 = -(D-D*)/(z-1), sigma1 = sgn(T1(1)), sigma2 = sgn(T2(1)), sigma3 = sgn(T3(1)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T1</td><td>- first polynomial of the recurrence, FLINT fmpq_poly_t type; used as aplaceholder for T1' </td></tr>
    <tr><td class="paramname">T2</td><td>- second polynomial of the recurrence, FLINT fmpq_poly_t type </td></tr>
    <tr><td class="paramname">T3</td><td>- third polynomial of the recurrence, FLINT fmpq_poly_t type </td></tr>
    <tr><td class="paramname">sigma1</td><td>- sign of T1 at x=1, fmpq_t type rational number </td></tr>
    <tr><td class="paramname">sigma2</td><td>- sign of T2 at x=1, fmpq_t type rational number </td></tr>
    <tr><td class="paramname">sigma3</td><td>- sign of T3 at x=1, fmpq_t type rational number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>results are stored in T1, T2, T3, sigma1, sigma2, sigma3 </dd></dl>

</div>
</div>
<a id="a6a5d65b06fef70ec6526bf54ab2518f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5d65b06fef70ec6526bf54ab2518f4">&#9670;&nbsp;</a></span>eval_at_1_sym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_at_1_sym </td>
          <td>(</td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates formaly-symmetric polynomial at x=1. </p>
<p>Uses Horner evaluation at 1 and symmetry of P </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>- the computed FLINT fmpq_t value P(1) </td></tr>
    <tr><td class="paramname">poly</td><td>- rational polynomial of FLINT fmpq_poly_t type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result is returned in val </dd></dl>

</div>
</div>
<a id="ad4f260f914469ff1b8cb24aac32fd047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f260f914469ff1b8cb24aac32fd047">&#9670;&nbsp;</a></span>get_coeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_coeff </td>
          <td>(</td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const slong&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns n-th coefficient of poly or 0 if index n is out of range. </p>
<p>Same as fmpq_poly_get_coeff_fmpq with a check for negative n </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeff</td><td>- FLINT fmpq_t type rational coefficient </td></tr>
    <tr><td class="paramname">poly</td><td>- FLINT fmpq_poly_t type rational polynomial </td></tr>
    <tr><td class="paramname">n</td><td>- FLINT slong type index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result is returned in coeff </dd></dl>

</div>
</div>
<a id="a548f5703cb4e36372f8d47c381007994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548f5703cb4e36372f8d47c381007994">&#9670;&nbsp;</a></span>get_coeff_numref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const fmpz* get_coeff_numref </td>
          <td>(</td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpz_t&#160;</td>
          <td class="paramname"><em>const_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const slong&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to numerator of n-th coefficient or 0 if index n is out of range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>- FLINT fmpq_poly_t type rational polynomial </td></tr>
    <tr><td class="paramname">n</td><td>- FLINT slong type index </td></tr>
    <tr><td class="paramname">const_null</td><td>- a reference to the FLINT fmpz_t variable that contains 0 constant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the numerator of n-th coefficient of poly as a pointer to FLINT fmpz </dd></dl>

</div>
</div>
<a id="a21ca22e6df635f27603116e1689fbcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ca22e6df635f27603116e1689fbcd4">&#9670;&nbsp;</a></span>get_delta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_delta </td>
          <td>(</td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T_prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T_curr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates delta coefficient for the three-term recursion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>- recursion coefficient, FLINT fmpq_t type </td></tr>
    <tr><td class="paramname">T_prev</td><td>- previous polynomial in the recursion, FLINT fmpq_poly_t type. </td></tr>
    <tr><td class="paramname">T_curr</td><td>- current polynomial in the recursion, FLINT fmpq_poly_t type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result is returned in delta </dd></dl>

</div>
</div>
<a id="a69fb049cdc47f06f6a700dedb019c2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fb049cdc47f06f6a700dedb019c2c9">&#9670;&nbsp;</a></span>get_lambda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">slong get_lambda </td>
          <td>(</td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of lowest non-zero term;. </p>
<p>0 if poly = 0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>FLINT fmpq_poly_t type rational polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FLINT slong type that is equal to index of first non-zero term in poly </dd></dl>

</div>
</div>
<a id="ad17b20e64b376242912269d3270ac337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17b20e64b376242912269d3270ac337">&#9670;&nbsp;</a></span>print_T_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_T_data </td>
          <td>(</td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debuging function; prints the recursion data to the stdout. </p>
<p>Prints n-th Polynomial T_n, lambda value of T_n and sigma=sgn(Tn(1)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- FLINT slong index of a sequence member </td></tr>
    <tr><td class="paramname">T</td><td>- n-th polynomial of the recurrence, FLINT fmpq_poly_t type </td></tr>
    <tr><td class="paramname">sigma</td><td>- sign of T_n at x=1, fmpq_t type rational number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52c6d0660a092928a2bc314e57270136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c6d0660a092928a2bc314e57270136">&#9670;&nbsp;</a></span>rule_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rule_init </td>
          <td>(</td>
          <td class="paramtype">fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_poly_t&#160;</td>
          <td class="paramname"><em>T2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>sigma1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmpq_t&#160;</td>
          <td class="paramname"><em>sigma2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fmpq_poly_t&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes polynomials T1, T2 and their signs at x=1. </p>
<p>T1 = (D+D*), T2 = (D-D*)/(z-1), sigma1 = sgn(T1(1)), sigma2 = sgn(T2(1)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T1</td><td>- first polynomial of the recurrence, FLINT fmpq_poly_t type </td></tr>
    <tr><td class="paramname">T2</td><td>- second polynomial of the recurrence, FLINT fmpq_poly_t type </td></tr>
    <tr><td class="paramname">sigma1</td><td>- sign of T1 at x=1, fmpq_t type rational number </td></tr>
    <tr><td class="paramname">sigma2</td><td>- sign of T2 at x=1, fmpq_t type rational number </td></tr>
    <tr><td class="paramname">D</td><td>- initial FLINT fmpq_poly_t type rational polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>results are is stored T1, T2, sigma1, sigma2 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
